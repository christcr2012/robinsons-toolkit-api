Custom GPT API Wrapper (Vercel)

A minimal, zero‚Äëbuild, serverless API that lets Custom GPT call your MCP tool handlers via REST.

> Goal: Avoid touching your MCP repos. This is a tiny, separate repo that Vercel will detect as serverless functions immediately.




---

1) Repo structure (must be at repo root)

/
‚îú‚îÄ api/
‚îÇ  ‚îú‚îÄ health.js
‚îÇ  ‚îî‚îÄ execute.js
‚îú‚îÄ package.json
‚îú‚îÄ README.md
‚îî‚îÄ (optional) openapi.json

> If you see 404s and functions: null in Vercel, 99% of the time the project‚Äôs Root Directory points to the wrong folder, or the /api folder isn‚Äôt at the project root. Fix that first (see Checklist below).




---

2) Files

api/health.js

// CommonJS export is the safest default for Vercel Serverless Functions
module.exports = (req, res) => {
  res.status(200).json({
    ok: true,
    ts: new Date().toISOString(),
    commit: process.env.VERCEL_GIT_COMMIT_SHA || 'dev'
  });
};

api/execute.js

// Minimal, defensive wrapper. Keep it CommonJS.
// Auth: pass x-api-key header. Set API_KEY in Vercel Project ‚Üí Environment Variables.

// Lazy require so cold starts only pay for what they use
function loadToolkit() {
  try {
    // If your toolkit is published to npm:
    // const { UnifiedToolkit } = require('robinsons-toolkit-mcp');

    // If not published, swap to a relative path or vendored copy:
    // const { UnifiedToolkit } = require('../vendor/robinsons-toolkit-mcp');

    // Placeholder implementation so this deploys before wiring the real package
    return {
      async init() {},
      async execute(tool, args) {
        // TODO: replace with: return UnifiedToolkit.executeToolInternal(tool, args)
        return { echo: { tool, args } };
      }
    };
  } catch (err) {
    // Surface import errors clearly
    throw new Error('Toolkit import failed: ' + (err && err.message));
  }
}

let toolkit; // singleton across invocations when hot

module.exports = async (req, res) => {
  try {
    // Method guard
    if (req.method !== 'POST') {
      return res.status(405).json({ error: 'Method Not Allowed' });
    }

    // Simple API key check (optional but recommended for GPT Actions)
    const key = req.headers['x-api-key'];
    if (process.env.API_KEY && key !== process.env.API_KEY) {
      return res.status(401).json({ error: 'Unauthorized' });
    }

    const body = typeof req.body === 'string' ? JSON.parse(req.body || '{}') : (req.body || {});
    const { tool, args } = body;
    if (!tool) return res.status(400).json({ error: 'Missing `tool`' });

    if (!toolkit) {
      toolkit = loadToolkit();
      if (toolkit.init) await toolkit.init();
    }

    // Call into your toolkit (replace with your real handler)
    const result = await toolkit.execute(tool, args || {});

    return res.status(200).json({ ok: true, result });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ ok: false, error: (err && err.message) || String(err) });
  }
};

package.json

{
  "name": "robinsons-toolkit-api",
  "private": true,
  "version": "0.1.0",
  "description": "Serverless API wrapper for Custom GPT ‚Üí Robinson's Toolkit",
  "license": "UNLICENSED",
  "main": "index.js",
  "scripts": {
    "start": "node -e \"console.log('use vercel dev')\""
  },
  "dependencies": {}
}

> No build step. Do not add type: module. Keep it ultra‚Äësimple.



README.md

# Robinson's Toolkit API (Vercel)

Minimal serverless wrapper that exposes MCP tool handlers over REST for Custom GPT Actions.

## Endpoints
- `GET /api/health` ‚Üí `{ ok: true }`
- `POST /api/execute` ‚Üí `{ ok: true, result: ... }`

## Auth
Send `x-api-key: <API_KEY>` header. Set `API_KEY` in Vercel ‚Üí Project ‚Üí Environment Variables.

## Local Dev
```bash
npm i -g vercel
vercel dev
# then hit http://localhost:3000/api/health

Wiring the Toolkit

Replace the placeholder in api/execute.js with your real import and call, e.g.:

const { UnifiedToolkit } = require('robinsons-toolkit-mcp');
// ...
const result = await UnifiedToolkit.executeToolInternal(tool, args);

Make sure the package is installable in Vercel (public npm or private with .npmrc token).

### (optional) `openapi.json` (for GPT Actions)
```json
{
  "openapi": "3.1.0",
  "info": { "title": "Robinson's Toolkit API", "version": "0.1.0" },
  "servers": [ { "url": "https://YOUR-DEPLOYMENT.vercel.app" } ],
  "paths": {
    "/api/health": {
      "get": {
        "operationId": "health",
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/api/execute": {
      "post": {
        "operationId": "execute",
        "security": [ { "api_key": [] } ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "tool": { "type": "string" },
                  "args": { "type": "object", "additionalProperties": true }
                },
                "required": [ "tool" ]
              }
            }
          }
        },
        "responses": {
          "200": { "description": "Execution result" },
          "400": { "description": "Bad request" },
          "401": { "description": "Unauthorized" },
          "500": { "description": "Server error" }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "api_key": { "type": "apiKey", "in": "header", "name": "x-api-key" }
    }
  }
}


---

3) Vercel Settings Checklist (to fix the 404 / functions: null issue)

1. Root Directory: must point to the folder that contains the /api directory at its top level. If your repo has /api at repo root, set Root Directory = /.


2. Framework Preset: Other.


3. Build Command: empty.


4. Output Directory: empty. (Don‚Äôt set to public/dist.)


5. vercel.json: Either delete it or keep it minimal; no custom routes at this stage.


6. File names: Use api/*.js (not .ts) until it works. Then, if you want TS, add it later.


7. Test: after deploy, hit https://<proj>.vercel.app/api/health. If this 404s, the Root Directory is wrong or /api isn‚Äôt at that root.



> Once GET /api/health returns 200, your functions are detected correctly. Then wire in the toolkit import and the OpenAPI.




---

4) Do we need a PostgreSQL DB?

No for the API wrapper itself. It only forwards calls to your handlers.

Yes/Maybe if specific tools you invoke depend on Postgres/Neon via Prisma (then keep the same env vars your MCP servers use, e.g., DATABASE_URL, etc.). If a tool doesn‚Äôt touch the DB, the wrapper won‚Äôt need it.


> Start with health working first (no DB). Then enable DB‚Äëdependent tools by adding the required env vars in Vercel.




---

5) Quick smoke tests

# Health
curl -i https://YOUR-DEPLOYMENT.vercel.app/api/health

# Execute (replace KEY if you set API_KEY)
curl -i -X POST \
  -H 'content-type: application/json' \
  -H 'x-api-key: KEY' \
  -d '{"tool":"ping","args":{"foo":"bar"}}' \
  https://YOUR-DEPLOYMENT.vercel.app/api/execute

If you see { ok: true, result: { echo: { tool: 'ping', args: { foo: 'bar' }}}}, routing works‚Äînow swap in your real handler import.


---

6) Wiring to Custom GPT (Actions)

1. Export the OpenAPI URL (raw file hosted in this repo or copy/paste JSON directly into the Actions editor).


2. Set Auth to API key and map it to the x-api-key header.


3. Add the execute endpoint as the main action; instruct the GPT to pass { tool, args }.


4. (Optional) Add specific endpoints for frequently used tools for tighter schemas & descriptions.




---

7) Next steps / hardening

Replace the placeholder in execute.js with your real UnifiedToolkit import + call.

Add per‚Äëtool Zod schemas to validate args.

Add timeouts and structured error objects.

Add tracing (e.g., console JSON, Logflare, or Vercel Observability).

Split into multiple endpoints if you want explicit OpenAPI for each tool.



---

8) Wire the real Toolkit (drop‚Äëin code)

Replace your current api/execute.js with this version that tolerates CJS/ESM and class/static styles:

// api/execute.js
// Auth via x-api-key (set API_KEY in Vercel ‚Üí Project ‚Üí Environment Variables)

let UnifiedToolkitRef = null;

function loadToolkitSync() {
  try {
    const mod = require('robinsons-toolkit-mcp'); // if published to npm
    return mod.UnifiedToolkit || (mod.default && mod.default.UnifiedToolkit) || mod;
  } catch (_) {
    try {
      // fallback to vendored copy if you checked code into /vendor
      const mod = require('../vendor/robinsons-toolkit-mcp');
      return mod.UnifiedToolkit || (mod.default && mod.default.UnifiedToolkit) || mod;
    } catch (_) {
      return null;
    }
  }
}

async function loadToolkitAsync() {
  try {
    const mod = await import('robinsons-toolkit-mcp');
    return mod.UnifiedToolkit || (mod.default && mod.default.UnifiedToolkit) || mod;
  } catch (_) {
    try {
      const mod = await import('../vendor/robinsons-toolkit-mcp/index.js');
      return mod.UnifiedToolkit || (mod.default && mod.default.UnifiedToolkit) || mod;
    } catch (err) {
      throw new Error('Toolkit import failed: ' + (err && err.message));
    }
  }
}

async function getUnifiedToolkit() {
  if (UnifiedToolkitRef) return UnifiedToolkitRef;
  UnifiedToolkitRef = loadToolkitSync();
  if (!UnifiedToolkitRef) UnifiedToolkitRef = await loadToolkitAsync();
  return UnifiedToolkitRef;
}

module.exports = async (req, res) => {
  try {
    if (req.method !== 'POST') return res.status(405).json({ error: 'Method Not Allowed' });

    const key = req.headers['x-api-key'];
    if (process.env.API_KEY && key !== process.env.API_KEY) return res.status(401).json({ error: 'Unauthorized' });

    const body = typeof req.body === 'string' ? JSON.parse(req.body || '{}') : (req.body || {});
    const { tool, args } = body;
    if (!tool) return res.status(400).json({ error: 'Missing `tool`' });

    const UnifiedToolkit = await getUnifiedToolkit();
    // If UnifiedToolkit is a class, instantiate; if it‚Äôs a module with functions, use as-is
    const instance = (typeof UnifiedToolkit === 'function') ? new UnifiedToolkit() : UnifiedToolkit;

    // Prefer executeToolInternal(tool, args), else fallback to execute(tool, args)
    const exec = instance.executeToolInternal || instance.execute || instance.run;
    if (!exec) return res.status(500).json({ error: 'Toolkit has no execute method' });

    const result = await exec.call(instance, tool, args || {});
    return res.status(200).json({ ok: true, result });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ ok: false, error: (err && err.message) || String(err) });
  }
};

Dependency options

A. Published npm package (ideal):

package.json ‚Üí "dependencies": { "robinsons-toolkit-mcp": "^x.y.z" }

npm i


B. Private npm (token): add an .npmrc with your registry + token, configure Vercel‚Äôs NPM_TOKEN.

C. Vendored copy: copy a minimal, runtime‚Äëonly build into vendor/robinsons-toolkit-mcp/ with an index.js that exports either UnifiedToolkit or { executeToolInternal(tool, args) }.


> Start with A if possible. C is the fastest if you just want to go live.




---

9) OpenAPI schema (pinned to your prod URL)

Create openapi.json in repo root (or /api/openapi.json) and use this:

{
  "openapi": "3.1.0",
  "info": { "title": "Robinson's Toolkit API", "version": "0.1.0" },
  "servers": [ { "url": "https://robinsons-toolkit-api.vercel.app" } ],
  "paths": {
    "/api/health": {
      "get": {
        "operationId": "health",
        "summary": "Health check",
        "responses": { "200": { "description": "OK" } }
      }
    },
    "/api/execute": {
      "post": {
        "operationId": "execute",
        "summary": "Execute a toolkit tool by name",
        "security": [ { "api_key": [] } ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "tool": { "type": "string", "description": "The tool name handled by UnifiedToolkit.executeToolInternal" },
                  "args": { "type": "object", "additionalProperties": true }
                },
                "required": [ "tool" ]
              }
            }
          }
        },
        "responses": {
          "200": { "description": "Execution result" },
          "400": { "description": "Bad request" },
          "401": { "description": "Unauthorized" },
          "500": { "description": "Server error" }
        }
      }
    }
  },
  "components": {
    "securitySchemes": {
      "api_key": { "type": "apiKey", "in": "header", "name": "x-api-key" }
    }
  }
}

> You can later split into one endpoint per tool for tighter schemas and better model ergonomics.




---

10) Quick GPT Actions hookup

1. In the GPT Builder, open Configure ‚Üí Actions ‚Üí Import from OpenAPI and paste the schema above. Map auth to header x-api-key.


2. In Instructions, remind the model to call /api/execute by passing { tool, args }.


3. Test in the Create tab: ‚ÄúRun tool ping with { foo: 'bar' }‚Äù and verify the echo.




---

11) Smoke tests (copy/paste)

# Health
curl -s https://robinsons-toolkit-api.vercel.app/api/health | jq

# Execute (replace KEY if API_KEY is set)
curl -s -X POST \
  -H 'content-type: application/json' \
  -H 'x-api-key: KEY' \
  -d '{"tool":"ping","args":{"foo":"bar"}}' \
  https://robinsons-toolkit-api.vercel.app/api/execute | jq


---

12) DB notes

Wrapper doesn‚Äôt need Postgres.

Individual tools that use Prisma/Neon will‚Äîjust set the same envs (DATABASE_URL, etc.) in Vercel Environment Variables.

If a tool opens many connections, consider Neon‚Äôs pooler or a serverless‚Äëfriendly client.



---

13) Per‚Äëtool endpoints (recommended for GPT Actions)

This adds clean, explicit endpoints that all delegate to your vendored UnifiedToolkit, improving tool selection for the model.

New files

api/
‚îú‚îÄ _util_tool.js
‚îî‚îÄ tools/
   ‚îú‚îÄ github-list-repos.js
   ‚îú‚îÄ github-create-issue.js
   ‚îú‚îÄ vercel-list-projects.js
   ‚îú‚îÄ neon-list-projects.js
   ‚îî‚îÄ openai-list-models.js

api/_util_tool.js

// Shared wrapper for tool endpoints (CommonJS). Zero build.
const { UnifiedToolkit } = require('../vendor/robinsons-toolkit-mcp');
let instance;

function getExec() {
  if (!instance) instance = new UnifiedToolkit();
  const exec = instance.executeToolInternal || instance.execute || instance.run;
  if (!exec) throw new Error('Toolkit has no execute method');
  return { exec, ctx: instance };
}

function makeToolHandler(toolName) {
  return async (req, res) => {
    try {
      if (req.method !== 'POST') return res.status(405).json({ error: 'Method Not Allowed' });
      const key = req.headers['x-api-key'];
      if (process.env.API_KEY && key !== process.env.API_KEY) return res.status(401).json({ error: 'Unauthorized' });
      const body = typeof req.body === 'string' ? JSON.parse(req.body || '{}') : (req.body || {});
      const { exec, ctx } = getExec();
      const result = await exec.call(ctx, toolName, body);
      return res.status(200).json({ ok: true, result });
    } catch (err) {
      console.error(err);
      return res.status(500).json({ ok: false, error: (err && err.message) || String(err) });
    }
  };
}

module.exports = { makeToolHandler };

Per‚Äëtool routes (all POST)

Each file is a tiny shim that fixes the tool name.

api/tools/github-list-repos.js

module.exports = require('../_util_tool').makeToolHandler('github_list_repos');

api/tools/github-create-issue.js

module.exports = require('../_util_tool').makeToolHandler('github_create_issue');

api/tools/vercel-list-projects.js

module.exports = require('../_util_tool').makeToolHandler('vercel_list_projects');

api/tools/neon-list-projects.js

module.exports = require('../_util_tool').makeToolHandler('neon_list_projects');

api/tools/openai-list-models.js

module.exports = require('../_util_tool').makeToolHandler('openai_list_models');

> Keep /api/execute for generic calls; these are explicit shortcuts with their own schemas below.




---

14) OpenAPI (per‚Äëtool) ‚Äî production URL

Create or replace openapi.json with the following:

{
  "openapi": "3.1.0",
  "info": { "title": "Robinson's Toolkit API ‚Äî Per‚Äëtool", "version": "0.2.0" },
  "servers": [ { "url": "https://robinsons-toolkit-api.vercel.app" } ],
  "paths": {
    "/api/health": { "get": { "operationId": "health", "responses": { "200": { "description": "OK" } } } },
    "/api/execute": {
      "post": {
        "operationId": "execute",
        "summary": "Generic execute (tool + args)",
        "security": [ { "api_key": [] } ],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "type": "object", "properties": { "tool": { "type": "string" }, "args": { "type": "object", "additionalProperties": true } }, "required": ["tool"] } } } },
        "responses": { "200": { "description": "Result" } }
      }
    },

    "/api/tools/github-list-repos": {
      "post": {
        "operationId": "github_list_repos",
        "summary": "List GitHub repositories",
        "security": [ { "api_key": [] } ],
        "requestBody": { "required": false, "content": { "application/json": { "schema": { "type": "object", "properties": { "user": { "type": "string", "description": "GitHub username" }, "org": { "type": "string", "description": "GitHub organization (optional)" } } } } } },
        "responses": { "200": { "description": "Repositories" } }
      }
    },

    "/api/tools/github-create-issue": {
      "post": {
        "operationId": "github_create_issue",
        "summary": "Create a GitHub issue",
        "security": [ { "api_key": [] } ],
        "requestBody": { "required": true, "content": { "application/json": { "schema": { "type": "object", "properties": { "owner": { "type": "string" }, "repo": { "type": "string" }, "title": { "type": "string" }, "body": { "type": "string" }, "labels": { "type": "array", "items": { "type": "string" } } }, "required": ["owner", "repo", "title"] } } } },
        "responses": { "200": { "description": "Issue created" } }
      }
    },

    "/api/tools/vercel-list-projects": {
      "post": {
        "operationId": "vercel_list_projects",
        "summary": "List Vercel projects",
        "security": [ { "api_key": [] } ],
        "requestBody": { "required": false, "content": { "application/json": { "schema": { "type": "object", "properties": { "teamId": { "type": "string", "description": "Optional Vercel team id" } } } } } },
        "responses": { "200": { "description": "Projects" } }
      }
    },

    "/api/tools/neon-list-projects": {
      "post": {
        "operationId": "neon_list_projects",
        "summary": "List Neon projects",
        "security": [ { "api_key": [] } ],
        "requestBody": { "required": false },
        "responses": { "200": { "description": "Projects" } }
      }
    },

    "/api/tools/openai-list-models": {
      "post": {
        "operationId": "openai_list_models",
        "summary": "List OpenAI models",
        "security": [ { "api_key": [] } ],
        "requestBody": { "required": false },
        "responses": { "200": { "description": "Models" } }
      }
    }
  },
  "components": {
    "securitySchemes": { "api_key": { "type": "apiKey", "in": "header", "name": "x-api-key" } }
  }
}


---

15) Env vars (required by tools)

Set in Vercel ‚Üí Project ‚Üí Environment Variables:

API_KEY ‚Äî your action auth

GITHUB_TOKEN ‚Äî repo scope for create‚Äëissue (read-only repo:read is fine for list)

VERCEL_TOKEN ‚Äî read access to projects (and team if needed)

NEON_API_KEY ‚Äî read access for projects

OPENAI_API_KEY ‚Äî for models list


> Add more as you register more tools.




---

16) Quick tests (per‚Äëtool)

# GitHub list repos
curl -s -X POST -H 'content-type: application/json' -H 'x-api-key: KEY' \
  -d '{"user":"christcr2012"}' \
  https://robinsons-toolkit-api.vercel.app/api/tools/github-list-repos | jq

# GitHub create issue (dry-run response until handler is wired)
curl -s -X POST -H 'content-type: application/json' -H 'x-api-key: KEY' \
  -d '{"owner":"christcr2012","repo":"my-repo","title":"Test from API"}' \
  https://robinsons-toolkit-api.vercel.app/api/tools/github-create-issue | jq

# Vercel projects
curl -s -X POST -H 'content-type: application/json' -H 'x-api-key: KEY' \
  -d '{}' https://robinsons-toolkit-api.vercel.app/api/tools/vercel-list-projects | jq

# Neon projects
curl -s -X POST -H 'content-type: application/json' -H 'x-api-key: KEY' \
  -d '{}' https://robinsons-toolkit-api.vercel.app/api/tools/neon-list-projects | jq

# OpenAI models
curl -s -X POST -H 'content-type: application/json' -H 'x-api-key: KEY' \
  -d '{}' https://robinsons-toolkit-api.vercel.app/api/tools/openai-list-models | jq

üî• Nailed it. Your vendored runtime path is exactly right‚Äîand now you‚Äôve got 5 real tools registered. I just dropped in the canvas:

Per-tool API routes (/api/tools/...) that all delegate to your vendored UnifiedToolkit

A tiny shared wrapper api/_util_tool.js

A per-tool OpenAPI (production-pinned) so Custom GPT gets clean, explicit actions

Env var checklist + curl tests


What to do now (quick):

1. Add the files from the canvas (section ‚Äú13‚Äì16‚Äù).


2. In Vercel ‚Üí Environment Variables, set:

API_KEY, GITHUB_TOKEN, VERCEL_TOKEN, NEON_API_KEY, OPENAI_API_KEY.



3. Hit the curl tests (also in the canvas).


4. Import the per-tool OpenAPI into GPT Builder ‚Üí Actions. You‚Äôll see separate actions:

github_list_repos, github_create_issue, vercel_list_projects, neon_list_projects, openai_list_models, plus the generic execute.




If you want, send me the exact arg shapes you used inside each handler and I‚Äôll tighten the OpenAPI schemas (types/enums/descriptions) so the GPT calls are perfectly constrained.